/*! @license ScrollReveal v4.0.9
 *  Licensed under the GNU General Public License 3.0 for
 *  compatible open source projects and non-commercial use.
 *  For commercial sites, themes, projects, and applications,
 *  keep your source code private/proprietary by purchasing
 *  a commercial license from https://scrollrevealjs.org/
 */

var ScrollReveal = (function () {
	"use strict";
  
	// Default configuration
	var defaultConfig = {
	  delay: 0,
	  distance: "0",
	  duration: 600,
	  easing: "cubic-bezier(0.5, 0, 0, 1)",
	  interval: 0,
	  opacity: 0,
	  origin: "bottom",
	  rotate: { x: 0, y: 0, z: 0 },
	  scale: 1,
	  cleanup: false,
	  container: document.documentElement,
	  desktop: true,
	  mobile: true,
	  reset: false,
	  useDelay: "always",
	  viewFactor: 0,
	  viewOffset: { top: 0, right: 0, bottom: 0, left: 0 },
	  afterReset: function () {},
	  afterReveal: function () {},
	  beforeReset: function () {},
	  beforeReveal: function () {}
	};
  
	var n = {
	  success: function () {
		document.documentElement.classList.add("sr");
		if (document.body) {
		  document.body.style.height = "100%";
		} else {
		  document.addEventListener("DOMContentLoaded", function () {
			document.body.style.height = "100%";
		  });
		}
	  },
	  failure: function () {
		document.documentElement.classList.remove("sr");
		return {
		  clean: function () {},
		  destroy: function () {},
		  reveal: function () {},
		  sync: function () {},
		  get noop() {
			return true;
		  }
		};
	  }
	};
  
	function isNode(e) {
	  return typeof window.Node === "object"
		? e instanceof window.Node
		: e !== null && typeof e === "object" && typeof e.nodeType === "number" && typeof e.nodeName === "string";
	}
  
	function selectAll(selector, container) {
	  if (container === undefined) container = document;
	  if (Array.isArray(selector)) return selector.filter(isNode);
	  if (isNode(selector)) return [selector];
	  if (typeof selector === "string") {
		try {
		  return Array.prototype.slice.call(container.querySelectorAll(selector));
		} catch (e) {
		  return [];
		}
	  }
	  return [];
	}
  
	function forEach(collection, callback) {
	  if (typeof collection === "object") {
		Object.keys(collection).forEach(function (key) {
		  callback(collection[key], key, collection);
		});
	  } else if (Array.isArray(collection)) {
		collection.forEach(function (value, index) {
		  callback(value, index, collection);
		});
	  } else {
		throw new TypeError("Expected either an array or object literal.");
	  }
	}
  
	function logDebug(message) {
	  if (this.constructor.debug && console) {
		console.log("%cScrollReveal: " + message, "color: #ea654b;");
	  }
	}
  
	function resetElements() {
	  var active = [];
	  var stale = [];
  
	  // Find active elements
	  forEach(selectAll("[data-sr-id]"), function (node) {
		var id = parseInt(node.getAttribute("data-sr-id"));
		active.push(id);
	  });
  
	  // Find stale elements
	  forEach(this.store.elements, function (element) {
		if (active.indexOf(element.id) === -1) {
		  stale.push(element.id);
		}
	  });
  
	  // Remove stale elements from the store
	  forEach(stale, function (id) {
		delete this.store.elements[id];
	  }, this);
  
	  // Update container and sequence stores
	  forEach(this.store.containers, function (container, id) {
		if (active.indexOf(container.id) === -1) {
		  stale.push(container.id);
		}
	  });
  
	  forEach(stale, function (id) {
		var node = this.store.containers[id].node;
		node.removeEventListener("scroll", this.delegate);
		node.removeEventListener("resize", this.delegate);
		delete this.store.containers[id];
	  }, this);
  
	  forEach(this.store.sequences, function (sequence, id) {
		if (active.indexOf(sequence.id) === -1) {
		  stale.push(sequence.id);
		}
	  });
  
	  forEach(stale, function (id) {
		delete this.store.sequences[id];
	  });
	}
  
	function mergeOptions(target) {
	  var sources = [];
	  for (var i = 1; i < arguments.length; i++) {
		sources[i - 1] = arguments[i];
	  }
  
	  forEach(sources, function (source) {
		forEach(source, function (value, key) {
		  if (typeof value === "object") {
			if (!target[key] || typeof target[key] !== "object") {
			  target[key] = {};
			}
			mergeOptions(target[key], value);
		  } else {
			target[key] = value;
		  }
		});
	  });
  
	  return target;
	}
  
	function revealTarget(target, options, container) {
	  if (container === undefined) container = this.store;
  
	  var elements = selectAll(target);
	  var config = mergeOptions({}, defaultConfig, options);
  
	  elements.forEach(function (element) {
		var id = element.getAttribute("data-sr-id");
		var storeElement = id ? container.elements[id] : { id: generateId() };
		storeElement.node = element;
  
		// Apply initial styles
		storeElement.styles = computeStyles(storeElement);
		applyStyles(storeElement.node, storeElement.styles.initial);
  
		container.elements[storeElement.id] = storeElement;
		element.setAttribute("data-sr-id", storeElement.id);
	  });
	}
  
	function computeStyles(element) {
	  var styles = {
		initial: "",
		generated: ""
	  };
  
	  var computed = window.getComputedStyle(element.node);
	  var opacity = parseFloat(computed.opacity);
	  var finalOpacity = isNaN(parseFloat(element.config.opacity))
		? opacity
		: parseFloat(element.config.opacity);
  
	  styles.initial = "opacity: " + opacity + ";";
	  styles.generated = "opacity: " + finalOpacity + ";";
  
	  if (element.config.distance) {
		var distance = parseDistance(element.config.distance);
		styles.initial += " transform: translate(" + distance.x + ", " + distance.y + ") " +
		  "rotate(" + element.config.rotate.x + "deg, " + element.config.rotate.y + "deg, " + element.config.rotate.z + "deg) " +
		  "scale(" + element.config.scale + ");";
		styles.generated += " transform: none;";
	  }
  
	  return styles;
	}
  
	function applyStyles(node, styles) {
	  node.setAttribute("style", styles);
	}
  
	function generateId() {
	  return ++idCounter;
	}
  
	function parseDistance(distance) {
	  var axis = distance.match(/[xy]/gi);
	  var value = parseFloat(distance.match(/\d+/));
	  var unit = distance.match(/[a-z%]+$/i);
  
	  switch (unit) {
		case "em":
		  value *= parseFloat(window.getComputedStyle(document.documentElement).fontSize);
		  break;
		case "px":
		  break;
		case "%":
		  value *= axis === "x"
			? document.documentElement.clientWidth / 100
			: document.documentElement.clientHeight / 100;
		  break;
		default:
		  throw new Error("Unrecognized distance unit.");
	  }
  
	  return {
		x: axis === "x" ? value : 0,
		y: axis === "y" ? value : 0
	  };
	}
  
	function reveal() {
	  var args = arguments;
  
	  setTimeout(function () {
		revealTarget.apply(this, args);
	  }.bind(this), 0);
	}
  
	function sync() {
	  var history = this.store.history;
	  history.forEach(function (entry) {
		reveal.call(this, entry.target, entry.options);
	  }.bind(this));
	}
  
	function ScrollReveal(options) {
	  if (!(this instanceof ScrollReveal)) {
		return new ScrollReveal(options);
	  }
  
	  if (!ScrollReveal.isSupported()) {
		logDebug.call(this, "This browser is not supported.");
		return n.failure();
	  }
  
	  try {
		this.defaults = mergeOptions({}, defaultConfig, options);
	  } catch (e) {
		logDebug.call(this, "Invalid configuration.", e.message);
		return n.failure();
	  }
  
	  if (!selectAll(this.defaults.container)[0]) {
		logDebug.call(this, "Invalid container.");
		return n.failure();
	  }
  
	  this.store = {
		containers: {},
		elements: {},
		history: [],
		sequences: {}
	  };
  
	  this.pristine = true;
	  this.initTimeout = null;
  
	  Object.defineProperty(this, "delegate", { get: function () { return delegate; } });
	  Object.defineProperty(this, "destroy", { get: function () { return destroy; } });
	  Object.defineProperty(this, "reveal", { get: function () { return reveal; } });
	  Object.defineProperty(this, "clean", { get: function () { return clean; } });
	  Object.defineProperty(this, "sync", { get: function () { return sync; } });
	  Object.defineProperty(this, "get noop", { get: function () { return false; } });
  
	  n.success();
	  return this;
	}
  
	ScrollReveal.isSupported = function () {
	  var style = document.documentElement.style;
	  return (
		"transform" in style || "WebkitTransform" in style || "MozTransform" in style
	  );
	};
  
	var idCounter = 0;
  
	var delegate = function () {
	  this.initTimeout = null;
	  if (!this.pristine) {
		resetElements.call(this);
	  }
	  this.pristine = false;
	};
  
	var destroy = function () {
	  var elements = selectAll("[data-sr-id]");
	  forEach(elements, function (node) {
		node.removeAttribute("data-sr-id");
	  });
	  this.store = null;
	  this.pristine = true;
	  clearTimeout(this.initTimeout);
	};
  
	var clean = function () {
	  var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	  if (!target) return;
	  var elements = selectAll(target);
	  elements.forEach(function (node) {
		var id = parseInt(node.getAttribute("data-sr-id"));
		if (id && this.store.elements[id]) {
		  applyStyles(node, "");
		  node.removeAttribute("data-sr-id");
		  delete this.store.elements[id];
		}
	  }.bind(this));
	};
  
	return ScrollReveal;
  })();
  
  if (typeof module !== "undefined" && module.exports) {
	module.exports = ScrollReveal;
  } else {
	window.ScrollReveal = ScrollReveal;
  }
  